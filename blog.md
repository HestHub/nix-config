


## Background

It all started a couple of weeks ago, when i decided that it would be fun to add some pictures to a blogpost to zhuzh it up a little, and what better way to get going other than using a stable-diffution AI?

It just ot happend to be that i have a fairly powerful graphicscard installed in my desktop machine, so why not seize the oppertunity and do some local AI experimentation. 

So on i go, and the first step in the AI journey is to enable the interface for AI models on my AMD card, which means installing ROCM, AMds version of CUDA. 

No problem i though, running PopOS, its as easy as an "apt install" command, right? 

Not quite, as it turns out.
My attempt to install ROCM failed, and failed so utterly and so brutally that the SSD containing the bootloader disappeared from the system, never to be found again.

So after spending a stormy,dark, week-long sunday afternoon troubleshooting, pulling hair and SATA cables in equal measure, i finally gave up and tallied up the system as condemned. 

Now the only way forward was to raze the ruins of my once working OS, pave over the lot and rebuild from scratch.

Maybe not the best of outcomes, but this did force me to start an old project that has been puttering in the backlog for quite some time now: Testing Nix as a daily driver, and what better time than now?


## What is, and why Nix

So what is Nix?

is it an OS? a pacakge manager? maybe a config language, or a shell environment?
How about all of the above? 

the Nix ecosystem consists of many parts, and they all work together to create a reproducible, immutable system.

This is, at least for me, the big selling point, that i can declaratively configure my system, store this config offsite, and reuse it on any machine, and easily bootstrap a new machine just the way i like it. 


SOME DETAILS ABOUT NIX

TODO EXPLAIN FLAKES


## installation

Step 1 - Livebooting nixOS and installing it on my Desktop.

   - picked up a a NixOS Image from here [NixOS](https://nixos.org/download/#nixos-iso)
   - burned it to a USB stick and booted from it. 

   otherwise a normal installation wizard, the only thing sticking out is the option to "Allow unfree software". 
   The default behaivour of nix is to only allow free, open source software, and you have to opt in to allow propriatary software to be installed on your system. 


   After a quick restart, booting into the installed system, its time to install some software. 

   during the installation, two very important nix files have been generated for us. 

   these are the config file, one looking at hardware, and the other at software, and they make up the basic strucute of nix.

   These are the files and way of working ill go through today, but there are more advanced features out there, something i will not look to closly today, but still worth mentioning. 

   Flake is an experimental feature....

   HomeManager is a system for managing user specific config....


   Maybe in the future, if i feel limited by what the base nix experience offer, ill look closer at incorperating these more advanced feature, but today ill stick to the basics.


.
   firstly is the hardware-configuration.nix, this file tells nix what hardware its working with, CPU architecture, hard-drives, network card, and also sets up the firmware we need, sets CPU architecture and points out hard-drive partitions. 

   So in short, hardware config lives here, and is something managed by nix itself, we dont edit this file by hand.

   ```
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "nvme" "xhci_pci" "ahci" "usbhid" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-amd" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/cca9e208-4d2a-4a8e-8b87-0c17d0a96475";
      fsType = "ext4";
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/E961-AFB0";
      fsType = "vfat";
      options = [ "fmask=0077" "dmask=0077" ];
    };

  swapDevices =
    [ { device = "/dev/disk/by-uuid/fcc5c3f9-836c-4eee-80d9-f03360b526ea"; }
    ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp38s0.useDHCP = lib.mkDefault true;
  # networking.interfaces.tailscale0.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlo1.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.amd.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}

   ```


   next up is the configuration.nix file, and here is where the magic happens. 

   this file works like a blueprint of the OS we want to setup, any changes we want to do to our system, its done using this file. 

   And here is the biggest difference between Nix and other distributions, since the OS is immutable, we dont install anything in the normal way, but we instead rebuild the entire system, with the added software bundled into it. 

   So if we take a look at my config file at first boot: 



   ```
 Edit this configuration file to define what should be installed on
# your system.  Help is available in the configuration.nix(5) man page
# and in the NixOS manual (accessible by running ‘nixos-help’).

{ config, pkgs, ... }:

{
  imports =
    [ # Include the results of the hardware scan.
      ./hardware-configuration.nix
    ];

  # Bootloader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  networking.hostName = "nixos"; # Define your hostname.
  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.

  # Configure network proxy if necessary
  # networking.proxy.default = "http://user:password@proxy:port/";
  # networking.proxy.noProxy = "127.0.0.1,localhost,internal.domain";

  # Enable networking
  networking.networkmanager.enable = true;

  # Set your time zone.
  time.timeZone = "Europe/Stockholm";

  # Select internationalisation properties.
  i18n.defaultLocale = "en_US.UTF-8";

  i18n.extraLocaleSettings = {
    LC_ADDRESS = "sv_SE.UTF-8";
    LC_IDENTIFICATION = "sv_SE.UTF-8";
    LC_MEASUREMENT = "sv_SE.UTF-8";
    LC_MONETARY = "sv_SE.UTF-8";
    LC_NAME = "sv_SE.UTF-8";
    LC_NUMERIC = "sv_SE.UTF-8";
    LC_PAPER = "sv_SE.UTF-8";
    LC_TELEPHONE = "sv_SE.UTF-8";
    LC_TIME = "sv_SE.UTF-8";
  };

  # Enable the X11 windowing system.
  services.xserver.enable = true;

  # Enable the GNOME Desktop Environment.
  services.xserver.displayManager.gdm.enable = true;
  services.xserver.desktopManager.gnome.enable = true;

  # Configure keymap in X11
  services.xserver.xkb = {
    layout = "us";
    variant = "";
  };

  # Enable CUPS to print documents.
  services.printing.enable = true;

  # Enable sound with pipewire.
  hardware.pulseaudio.enable = false;
  security.rtkit.enable = true;
  services.pipewire = {
    enable = true;
    alsa.enable = true;
    alsa.support32Bit = true;
    pulse.enable = true;
    # If you want to use JACK applications, uncomment this
    #jack.enable = true;

    # use the example session manager (no others are packaged yet so this is enabled by default,
    # no need to redefine it in your config for now)
    #media-session.enable = true;
  };

  # Enable touchpad support (enabled default in most desktopManager).
  # services.xserver.libinput.enable = true;

  # Define a user account. Don't forget to set a password with ‘passwd’.
  users.users.hest = {
    isNormalUser = true;
    description = "hest";
    extraGroups = [ "networkmanager" "wheel" ];
    packages = with pkgs; [
    #  thunderbird
    ];
  };

  # Enable automatic login for the user.
  services.xserver.displayManager.autoLogin.enable = true;
  services.xserver.displayManager.autoLogin.user = "hest";

  # Workaround for GNOME autologin: https://github.com/NixOS/nixpkgs/issues/103746#issuecomment-945091229
  systemd.services."getty@tty1".enable = false;
  systemd.services."autovt@tty1".enable = false;

  # Install firefox.
  programs.firefox.enable = true;

  # Allow unfree packages
  nixpkgs.config.allowUnfree = true;

  # List packages installed in system profile. To search, run:
  # $ nix search wget
  environment.systemPackages = with pkgs; [
  #  vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.
  #  wget
  ];

  # Some programs need SUID wrappers, can be configured further or are
  # started in user sessions.
  # programs.mtr.enable = true;
  # programs.gnupg.agent = {
  #   enable = true;
  #   enableSSHSupport = true;
  # };

  # List services that you want to enable:

  # Enable the OpenSSH daemon.
  # services.openssh.enable = true;

  # Open ports in the firewall.
  # networking.firewall.allowedTCPPorts = [ ... ];
  # networking.firewall.allowedUDPPorts = [ ... ];
  # Or disable the firewall altogether.
  # networking.firewall.enable = false;

  # This value determines the NixOS release from which the default
  # settings for stateful data, like file locations and database versions
  # on your system were taken. It‘s perfectly fine and recommended to leave
  # this value at the release version of the first install of this system.
  # Before changing this value read the documentation for this option
  # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
  system.stateVersion = "24.05"; # Did you read the comment?

}
   ```

here we can se a couple of intreseting things: 

Nix the language - its the language we use to describe our derivations. its a fully functional language, so everything is done using expressions, so great if you feel functional yourself, otherwise its something to get used to.

we have a set of different domains that we configure in this file, 
first a couple that get configured during the installation, and that ill leave as is:

- boot
- networking
- time
- i18n 
- users


and then we have the three main domains that will add some useful software to our system: 

services, programs and systemPackages. 

Im sure there are more nuances to it, but im seperating them into rough categories

services handles background processes, and deamon, for example displaymanager, and pipewire (sound), Later on i also use a service to enable a VPN client called tailscale. 

services.tailscale.enable = true;

simple as that. 


the next two, programs and systemsPackages are similar to each other, and a quick and dirty way to look at is that systemPackages are the basic install flow, and will simply put a binary in PATH and thats it.

But if we install using programs.ABC we can include some config options directly during the installation, otherwise config has to be done manually ( or using the HomeManager feature).

So lets give it a go, first thing i wanted installed was:
 
- vim (instead of the bundled nano)
- bitwarden as a password manager
- fish as my interactive shell
- git
- vscodium
- gnomeExtensions.pop-shell (to handle tiled windows)
- steam (game store/library)
- discord
- slack


and all of this is as simple as adding a couple of lines to our systemPackage attribute like this:

```
environment.systemPackages = with pkgs; [
   vim 
   gnomeExtensions.pop-shell
   bitwarden
   discord
   slack
   git
   vscodium
  ];

```

and for steam, which has some extra config options we can provide, we do this:


```
  programs.steam = {
    enable = true;
    remotePlay.openFirewall = true; # Open ports in the firewall for Steam Remote Play
    dedicatedServer.openFirewall = true; # Open ports in the firewall for Source Dedicated Server
    localNetworkGameTransfers.openFirewall = true; # Open ports in the firewall for Steam Local Network Game Transfers
  };

```

and as a final touch, we add fish as the default shell for my user, updating the users item for my user:

```
 users.users.hest = {
    isNormalUser = true;
    description = "hest";
    shell = pkgs.fish;  # NEW LINE
    extraGroups = [ "networkmanager" "wheel" ];
    packages = with pkgs; [
    #  thunderbird
    ];
  };

```

With these changes in place, we are now ready to rebuild our system, creating a new "generation" of the setup. 

this is done using the nix cli command `nixos-rebuild`.

`nixos-rebuild switch` will build the config and activate the new generation right away, so any new binaries install are available, and will also add a new record to our boot menu, making the new generation default. 

TODO PICTURE OF BOOTLOADER

if we instead want to tag our build with something specific we can add the flag `-p NAME` or `--profile-name NAME`, giving a more discriptive name other than the date it was built.


### auto login
Great, now its much more manageble to edit files with vim, so lets add some more config, next up is a small tweak to autologin on boot: 

first attempt didn't quite pan out, went to [nix options search]() and found this, which looked promising

```
  # autologin without password
  services.displayManager.autoLogin.enable = true;
  services.displayManager.autoLogin.user = "hest";

```

added the lines to config and did a `nixos-rebuild switch`, no problem detected, but then i rebooted to test the feature, but something wasn't quite right. the OS booted alright, and even logged in automaticly, but a second later i was kicked out and had to login manually either way. 

After som scanning around the forums i found a workaround: 

```
  # Workaround for GNOME autologin: https://github.com/NixOS/nixpkgs/issues/103746#issuecomment-945091229
  systemd.services."getty@tty1".enable = false;
  systemd.services."autovt@tty1".enable = false;
```

not sure why it happens, but if it works it works right? [forum discussion](https://discourse.nixos.org/t/gnome-display-manager-fails-to-login-until-wi-fi-connection-is-established/50513/14)


### containerization and VPN

next up - virtualization and VPN

adding this snippet of config, one service to enable tailscale VPN, and virtualization has its own "toplevel" domain to configure.

```
  # enable tailscale VPN
  services.tailscale.enable = true;

  # enable containerization ( podman ) 
  virtualisation.containers.enable = true;
  virtualisation = {
    podman = {
      enable = true;

      # Create a `docker` alias for podman, to use it as a drop-in replacement
      dockerCompat = true;

      # Required for containers under podman-compose to be able to talk to each other.
      defaultNetwork.settings.dns_enabled = true;
    };
  };

```

then lets add some useful CLI tools: 

```

  environment.systemPackages = with pkgs; [
   ... same as before

   # VPN
   tailscale
   trayscale

   # containers
   podman
   podman-compose
   podman-desktop
   
   ];

```

One `nixos-rebuild switch` later, and we have tailscale VPN and podman containers ready to go.


### nix shell

But what if you just need a cli tools ones in a blue moon, or just want to get a feel for some alternatives before you permanently install it?

then we can turn our eyes to the nix-shell! 

nix shell lets us create a temporary PATH enviroment, install all the dependencies we need for a package and have it availible only as long as the current session is running. 

so say i need to get some data from a json, but cant be bothered installing jq the normal route, editing config, rebuilding, creating a new generation just for a one off command?
lets just nix-shell it: 

```

hest@nixos ~> jq
The program 'jq' is not in your PATH. You can make it available in an
ephemeral shell by typing:
  nix-shell -p jq
hest@nixos ~ [127]> nix-shell -p jq
these 55 paths will be fetched (74.04 MiB download, 349.22 MiB unpacked):
...
...
...

```

5 seconds later, the nix shell is ready to go:

```
[nix-shell:~]$ echo {} | jq .
{}

```

a nice little feature to have, being able to setup a quick test environment, test out some fun app or CLI i found online, and when im done, not having to worry about just files and unused packages clogging down the system. 


### nix-command and flakes

Speaking of nice, features, lets do a quick detour and just toke at nix flakes.

I know i said i wont be using flakes today, but this will be quick, ill just make the system ready for them, and test out a flake i found.

So in order to enable some experimental features, we add this line to our config:

```
nix.settings.experimental-features = [ "nix-command" "flakes" ];
```

rebuild, and we have both flakes and the new nix command at our fingertips. 

So now we are ready to build and use flakes.

i did do some experimentation with this flake: [nixified-AI](github:nixified-ai/flake#invokeai-amd) a flake of [InvokeAI](https://www.invoke.com/), a platform to run text-to-image AI locally. 

at first i tried to run it directly from github

```
nix run github:nixified-ai/flake#textgen-amd
```

but something didn't sit quite right, the installation stalled and never finish, or more acruratly i gave up when it was still running after i had been away for 20ish minutes. 

so next step was to download the repo and run it locally. 

```
git clone https://github.com/nixified-ai/flake
cd flake
nix run .#invokeai-amd

```

2-3 min of installation, and just like that, i have a local text-to-image AI running on my GPU, not bad, will have to play around with that later.

### Gaming and mounting extra hard-drives

6. added mounted extra disks, the solution was to mount as i wanted them, the ran "sudo nixos-generate-config", which updates the hardware config, adding my other SSDs permanently to the setup.

So right about now im feeling quite good with the programs and tools installed, everything installed "just works" right out of the bat. 

Next up was testing some games, steam installed, proton enabled, [Against the Storm](https://store.steampowered.com/app/1336490/Against_the_Storm/) downloaded and off we go. 

Works perfectly, great FPS, no screen tearing, artifacts or other graphical issues.
No weirdness with keyboard or mouse controls, and i think the GPU barely started up the fans running it, 10/10. 

But since i have multiple SSDs in my system and the OS installed my "tiny" 500GB M.2 drive, i would prefer to put all my games the 1TB Nvme drive, just incase i once again manage to turn the OS into sludge, and to be honest it does feel inevitable, given enough time and tinkering. 

But right now i can only see my OS disk, nothing else is mounted when i start the system, so how to make sure all the disks are mounted and accessible at boot? 


this is where to hardware-configuration.nix comes into play. 

The solution i found did require a couple of manual steps, but im sure it can be handled automaticly, either with scripts or with some deeper nix knowledge, but what i did was:

  1. mount the drives (make sure they are mounted under /mnt and not /tmp/run/ which "disks" will do by default; It wont work if they are in temp folder)
  2. update the hardware config by running `sudo nixos-generate-config` 
  3. profit, now we have the disk mounted at boot, managed by nix.

No, its not to much trouble, and yes, i would survive manually performing this herculean feat of strength every time i set up a system from scratch.

But wouldn't it be nice if this was done for you? For now i put it aside and put my future hopes toward [HomeManager] and [Flakes].

### found issue with command not found 

ran into to an annoying issue when commanding away at the terminal, an unplesant database error popped up if i fat-fingered a command.

```
hest@nixos ~> claer
DBI connect('dbname=/nix/var/nix/profiles/per-user/root/channels/nixos/programs.sqlite','',...) failed: unable to open database file at /run/current-system/sw/bin/command-not-found line 13.
cannot open database `/nix/var/nix/profiles/per-user/root/channels/nixos/programs.sqlite' at /run/current-system/sw/bin/command-not-found line 13.
hest@nixos ~ [127]> 
```

seems like this had something to do with the channel nix was listening to by default, 
but just adding the proper nixos-unstable and a quick update, and no more DB issues. 


```
hest@nixos ~> nix-channel --add https://nixos.org/channels/nixos-unstable nixos
hest@nixos ~> nix-channel --update
```

```
hest@nixos ~> claer
claer: command not found
hest@nixos ~ [127]> 
```

### clean up the nix store

As a final step in this config i wanted to tidy up a bit around the nix store and bootloader. 

with all the different derivations and generations on the system after a couple of weeks of rebuilding, the size of the nix store can grow rather large

```
hest@nixos ~> du /nix/store/ -sh
21G	/nix/store/
```

21 GB might not be to bad, but this will grow quickly, every new generation putting seperate versions of the packages nix installs in the store. 

Every nix generation will also add a new record to our bootloader, making that swell up too.

TODO picture of bootloader

So wrapping up this first chapter of my nix config will be to see if i can handle this in a graceful manner. 

Lets see how it can be done manually: 

starting out by finding all the stored generations on the system:

```
nix-env --list-generations
```

will do the trick, but since i have installed everything system-wide (using the sytemPackages domain),
i also need to point out that im using the system profile in this case:

```
sudo nix-env --list-generations --profile /nix/var/nix/profiles/system

   1   2024-10-12 02:11:56   
   2   2024-10-12 15:33:14   
   3   2024-10-12 17:59:32   
   4   2024-10-12 21:59:04   
   5   2024-10-20 13:16:04   
   6   2024-10-20 13:21:57   
   7   2024-10-20 20:45:41   
   8   2024-10-22 21:23:08   (current)

```

For this manual step, we can try to clear up everything not used: 

```
sudo nix-env --delete-generations old --profile /nix/var/nix/profiles/system

sudo nix-env --delete-generations old --profile /nix/var/nix/profiles/system

   8   2024-10-22 21:23:08   (current)

```
great, no trouble here, so lets look at the store now that we have some dangling packagees from the old generations. 
The nix-store cli lets us do a manual garbage collet:

```
nix-store --gc
deleting unused links...
note: currently hard linking saves 4337.25 MiB
1155 store paths deleted, 654.20 MiB freed

```

But according to the documentation, this is a command you should not have to handle manually in normal circumstances.

So lets automate this using our configuration instead.

The [Wiki](https://nixos.wiki/wiki/Storage_optimization) 
shows that its possbile to handle cleanup for both the generations and the store automaticly.

The most straightforward options seems to be a scheduled cleanup, ill go for once a week,
and only keep the last 3 generations, so if anything goes wrong in the future, i have something to revert back to.

For the store cleanup i opted for an even easier option, optimise after every build, so from now on,
every time i build a new generation, a cleanup of dangling packages will be performed.

```
  nix.gc = {
    automatic = true;
    dates = "weekly";
    options = "--delete-older-than +3";
  };

  nix.settings.auto-optimise-store = true;

```

And with that my v1 config for nixos is complete, 
and this is the configuration ive been using as a daily driver for about two weeks now.

Almost all of the config work was done upfront, and during the last 12 or so days
ive only added some minor tweaks: replacing a package here, adding something extra there.
Overall the system has been rock solid, and so far im really happy with how it turned out. 

Now for the finishing touch, the pièce de résistance of this build:
I will completly wipe my hard-drive, reinstall NixOS from strach using my config file and see if there is anything missing.

So lets save this config to github, wipe it all and see what happends.

TODO add pictures of Installation

TODO describe all manual steps needed

TODO add final config file